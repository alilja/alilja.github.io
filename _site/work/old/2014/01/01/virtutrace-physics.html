<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>VirtuTrace Physics Engine Rebuild | Andrew Lilja</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="VirtuTrace Physics Engine Rebuild" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In our lab, we try to get insights about high-intensity, time-pressured decisions made by people like soldiers, firefighters, and police officers. To do this, we use VirtuTrace, our flagship simulator software that runs in the C6, one of the largest CAVEs in the world. We like the C6 because it allows us to get really high ecological validity for our studies, but until recently, our simulations did not support dynamic physics — once the scene was loaded, none of the objects could move." />
<meta property="og:description" content="In our lab, we try to get insights about high-intensity, time-pressured decisions made by people like soldiers, firefighters, and police officers. To do this, we use VirtuTrace, our flagship simulator software that runs in the C6, one of the largest CAVEs in the world. We like the C6 because it allows us to get really high ecological validity for our studies, but until recently, our simulations did not support dynamic physics — once the scene was loaded, none of the objects could move." />
<link rel="canonical" href="http://localhost:4000/work/old/2014/01/01/virtutrace-physics.html" />
<meta property="og:url" content="http://localhost:4000/work/old/2014/01/01/virtutrace-physics.html" />
<meta property="og:site_name" content="Andrew Lilja" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-01-01T10:22:34-06:00" />
<script type="application/ld+json">
{"description":"In our lab, we try to get insights about high-intensity, time-pressured decisions made by people like soldiers, firefighters, and police officers. To do this, we use VirtuTrace, our flagship simulator software that runs in the C6, one of the largest CAVEs in the world. We like the C6 because it allows us to get really high ecological validity for our studies, but until recently, our simulations did not support dynamic physics — once the scene was loaded, none of the objects could move.","headline":"VirtuTrace Physics Engine Rebuild","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/work/old/2014/01/01/virtutrace-physics.html"},"@type":"BlogPosting","url":"http://localhost:4000/work/old/2014/01/01/virtutrace-physics.html","dateModified":"2014-01-01T10:22:34-06:00","datePublished":"2014-01-01T10:22:34-06:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="https://use.typekit.net/vyv0ypb.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Andrew Lilja" /></head><body>
    <main class="content" aria-label="Content">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">VirtuTrace Physics Engine Rebuild</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-01-01T10:22:34-06:00" itemprop="datePublished">Jan 1, 2014
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In our lab, we try to get insights about high-intensity, time-pressured
decisions made by people like soldiers, firefighters, and police
officers. To do this, we use VirtuTrace, our flagship simulator software
that runs in the <a href="http://www.vrac.iastate.edu/facilities/c6/">C6</a>, one
of the largest
<a href="http://en.wikipedia.org/wiki/Cave_automatic_virtual_environment">CAVE</a>s
in the world. We like the C6 because it allows us to get really high
ecological validity for our studies, but until recently, our simulations
did not support dynamic physics — once the scene was loaded, none of the
objects could move.</p>

<p>It was my job to update the engine to allow for fully dynamic physics:
tools floating in zero-g in the International Space Station, houses
exploding in war zones, and even car collisions were all required in
upcoming projects. We were using the <a href="http://bulletphysics.org/">Bullet</a>
physics engine just to stop people from walking through walls, but it
was designed for truly dynamic physics simulations, so I didn’t have to
replace it. Even better, a <a href="https://github.com/mccdo/osgbullet">library</a>
exists that ties together our visual rendering and object hierarchy tree
(<a href="http://www.openscenegraph.org">OpenSceneGraph</a>) and Bullet, saving me
even more time.</p>

<p>I think of code refactoring as a sort of design problem. The users are the developers
who have to read, understand, and use your API<sup id="fnref:fn-api"><a href="#fn:fn-api" class="footnote">1</a></sup> to get their job done
and the developers who have to edit your code to add a new feature or
fix a bug. The API user’s goal could be anything your system allows (and
in some cases, <em>doesn’t</em> allow), so a good one needs to have clear and
explicit patterns while still remaining flexible. In contrast, the bug
fixer just wants to get in and solve their problem without spending a
ton of time digging around in complex, arcane code looking for a minus
sign in the wrong spot. I also had to make migration from the old,
static scenes to the new dynamic physics scenes as painless as possible,
which meant that no matter how fancy I wanted to get, the inputs and
outputs all had to look the same (or very similar). There’s nothing
worse than updating a library and finding out that nothing works the way
you expect it to, so now you have go back and rewrite all your old code.</p>

<p>I discussed this at length with my primary stakeholders: Kevin, the
initial developer of VirtuTrace and its main developer once I leave, and
Nir, our advisor, who needs to understand its features and limitations
when designing experiments. It was very important to Nir that the
physics were realistic, but Kevin wasn’t able to spend a ton of his time
rewriting old scenes to make them play nice with the new code. Nir had a
long list of features he wanted to see, including zero-g, variations in
mass, size, and even mass distribution (so a hammer could be heavier at
one end, for example). Even though Nir wanted a bunch of features,
Kevin’s need for an easy upgrade meant that I couldn’t just tear
everything out and start from scratch.</p>

<p>As I read through the code and experimented with changes, however, I quickly
discovered that it would be very challenging to create all these
features without breaking compatibility with old code. This led to two
key decisions: first, there should be a clear distinction between
<em>static</em> objects and <em>dynamic</em> objects, and that everything should be
static unless someone <em>explicitly</em> told them not to be. This way, old
scenes would be able to play nice with the new system, and if anyone
ever wanted to upgrade them to a dynamic scene, they would be going out
of their way to make that choice, as opposed to having it forced upon
them by the design of the system<sup id="fnref:fn-staticdynamic"><a href="#fn:fn-staticdynamic" class="footnote">2</a></sup>.</p>

<p>The very first thing I did was find out what wasn’t necessary.
The original, static method looked at all the objects in the scene,
created invisible boxes around each of them, and then froze them in
place. This worked fine when things weren’t moving, but it wasn’t going
to fly with dynamic physics. For one thing, keeping track and
synchronizing the locations of pairs of objects would be a huge hit to
performance. The old method was going to have to go. While this meant
starting over in several areas, it had a nice upside and an unexpected
downside. Bullet provides an API for adding dynamic objects
(<code class="language-plaintext highlighter-rouge">btRigidBodies*</code> in the Bullet parlance), which allowed me to specify
things like mass, size, and starting position. The downside was that all
the previous code that had done the math to put objects in the right
spot had to be removed, and because of a mismatch between how positions
were entered by the programmer and how Bullet expected them, that math
now fell to <em>me</em><sup id="fnref:fn-linear"><a href="#fn:fn-linear" class="footnote">3</a></sup>.</p>

<p>Here’s an example of what it looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>osg::MatrixTransform* master_node = new osg::MatrixTransform();
master_node-&gt;setName(model_id);

osg::Matrix matrix = osg::Matrix::scale(scale_x, scale_y, scale_z)
* osg::Matrix::rotate(osg::inDegrees(rotate_x), osg::X_AXIS)
* osg::Matrix::rotate(osg::inDegrees(rotate_y), osg::Y_AXIS)
* osg::Matrix::rotate(osg::inDegrees(rotate_z), osg::Z_AXIS)
* osg::Matrix::translate(position);
osg::MatrixTransform* static_matrix_transform = new osg::MatrixTransform(matrix);
std::vector&lt;osg::Node* &gt; non_collision_nodes = physics_visitor-&gt;get_non_collision_nodes();
for(std::vector&lt;osg::Node* &gt;::iterator iter = non_collision_nodes.begin(); iter != non_collision_nodes.end(); ++iter){
    static_matrix_transform-&gt;addChild((*iter));
}
master_node-&gt;addChild(static_matrix_transform);
</code></pre></div></div>

<p>Instead of handling the initial construction and setup of dynamic and static objects
separately, I decided to treat their creation as if they were identical
until they <em>really</em> needed to be handled differently. This allowed me to
use the many of the same functions and math for both kinds of objects,
greatly simplifying the process and speeding up the simulation. Because
the math was the same, the various steps of the APIs could both point to
the same function when they needed, but still do their own independent
steps. This saved me a lot of time, and made it substantially easier for
future programmers to look at my code and see how all the pieces fit
together. With the new positioning code written, I could remove the old,
redundant code that already existed. However, doing this would remove
the API hooks the static scenes relied on, so I created new hooks that
were identical in name to the old ones, but just pointed to the new
code<sup id="fnref:fn-best"><a href="#fn:fn-best" class="footnote">4</a></sup>.</p>

<p>With the new code in place, I had assumed everything would work. And in
tests, it did! Objects flying at each other would bounce off the floors
and walls, and objects would drop out of the sky with gravity pulling
them down — and the old scenes still worked just fine. The only problem
was that the player object couldn’t interact with the dynamic objects.
It didn’t matter what the mass or size of the object was: as soon as the
player walked into it, they stopped dead. This was initially amusing, as
players floating down the International Space Station would come to a
crashing halt when they run into a screwdriver floating in the air. But
this wasn’t exactly a high-fidelity simulation.</p>

<p>The solution was not easy to find. I tried a huge range of fixes, from
changing the way the physics engine treated the player object to writing
my own collision math specifically for dealing with the player. I talked
to Kevin and Nir looking for insights and advice, and I contacted the
much more experienced Ph.D students who worked in VRAC. No one could
help me. I turned to the archaic, spotty, and inconsistent Bullet
documentation over and over again, reading every page, forum post,
commit message, and code comment that seemed promising.</p>

<p>In the end, it was this exhaustive coverage of the documentation that
led me to my answer. Nestled in an unrelated page of the Bullet wiki was
a brief mention that player objects could have collision filters applied
to them using an old-style method from the previous version of Bullet.
Nowhere else in the official documentation was this listed, and the
function didn’t even document that it could accept that kind of input.
But lo and behold, it worked.</p>

<p>The conversion was even more challenging than I expected. The end result
fit what both Kevin and Nir wanted, making the upgrade process painless
and providing most of the features Nir asked for with the potential to
add the rest in the near future. I tried to make my code as clear as
possible, leaving documenting comments in areas that seemed confusing
and breadcrumb trails showing how all the parts connected. And if
developers were still confused, I made sure that my email address was
available for them.</p>

<div class="footnotes">
  <ol>
    <li id="fn:fn-api">
      <p>Application Programming Interface; the hooks and tie-ins to your system that let developers use it for their own purposes. <a href="#fnref:fn-api" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fn-staticdynamic">
      <p>One unexpected benefit of these choices was that it was easy to mix static and dynamic objects together. If you wanted to add just one dynamic thing to an old static scene, you didn’t need to rewrite all the code — just use the new dynamic API along with the old static one. <a href="#fnref:fn-staticdynamic" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fn-linear">
      <p>I wound up learning almost an entire class’ worth of linear algebra for this. I let the computer handle the <a href="http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">four-dimensional rotation matrices</a>, though. <a href="#fnref:fn-linear" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:fn-best">
      <p>In the end, this was the best decision I made. It meant that the physics system could live in one spot and share as much code as possible while still allowing for old code to talk to it. The inputs and outputs stayed the same, it was just the inside that changed. <a href="#fnref:fn-best" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/work/old/2014/01/01/virtutrace-physics.html" hidden></a>
</article>

    </main>
</body>
</html>